閱讀完成日: 20240922
心得: 對於理解python應該算是進階，但是依然還沒到最深，畢竟都沒有看到c層面的代碼，不過對於目前的我來說已經過於足夠，應該短期內也不會到更深了，如果要更深，就要把書籍再讀一遍，無法理解而跳過的部分重新了解之外，還要再讀C語言。

[書籍程式碼下載](http://books.gotop.com.tw/download/ACL059900)

- Ch01 Python起步走
	- 重要 PEPs: 
		- **PEP 1**：PEP (Python Enhancement Proposal) 的目的是描述一項新功能，收集社群的意見並記錄其決策過程。
		- **PEP 8**：提供了撰寫Python程式碼時應遵循的編碼風格指南，以提高程式碼的可讀性和一致性。
		- **PEP 20**：包含了稱為“Zen of Python”的20條箴言，總結了Python設計的核心原則和哲學。
		- **PEP 257**：定義了Python中docstring（文件字串）的格式標準，用於撰寫內部文件和API文件。
		- **PEP 333**：定義了Python Web伺服器閘道介面（WSGI），標準化了Python web應用程序與web伺服器之間的通訊協定。
		- **PEP 484**：引入了可選的型別提示，讓開發者可以在程式碼中明確標註變數和函數的型別，增強程式碼的可讀性和靜態分析能力。
		- **PEP 3107**：引入了函數注解，允許開發者在函數定義中添加額外的元數據，這在設計API和進行靜態型別檢查時非常有用。
		- **PEP 572**：引入了命名表達式，允許在表達式內進行變數賦值，簡化了一些常見的編碼模式。
		- **PEP 618**：引入了新的語法特性以支援並行處理，這在現代多核處理器和並行計算需求下變得非常重要。
	- PyCon研討會
	- LocalUserGroups
	- 實作方式
		- CPython
		- PyPy
		- Jython
		- IronPython
	- pyhon390.chm: Python 文件
	- site-packages: 第三方程式庫存放位置
	- Scripts: pip and easy_install相關指令
	- Tools: 範例程式碼與一些工具程式
	- [[Command Ch01]]
- Ch02 從REPL到IDE   
	- python是來自影劇: Monty Python's Flying Circus
	- 舊版windows記事本開頭可以註解編碼方式
	- 套件名稱會成為名稱空間一部分
	- [[Command Ch02]]
- Ch03 型態與運算子   
	- Father of Pascal: Niklaus E. Writh說過: Algorithms + Data Structure = Programs
	- Python 所有資料都是物件
	- 數字中間可以加上底線，方便閱讀
	- python 3.6之後才有f字串
	- Duck Typing
	- Bitwise Operators: & | ^ ~ >> <<
	- 位元運算子還可以用在set上面
	- `* `可以拆解迭代物件, `**` 可以將dict的值也拆出來
	- Python 3.5(PEP 448)增加Additional Unpacking Generalizations 
	- 需要處理精確的小數運算結果，使用`decimal.Decimal`類別
- Ch04 流程語法與函式   
	- Python 3.8有海象運算子
	- 可以將超過一個list作list comprehension
	- [遞迴的美麗與哀愁](openhome.cc/Gossip/Programmer/Recursive.html)
	- Python 3.8 PEP570: Positional-Only Parameters (`*` 與 `/` ) 
	- python map
	- python 中的全域，是以模組檔案為界
	- `dir()`可以查詢指定物件上可用的名稱
	- `locals()`可以查詢區域變數的名稱與值
	- `yeild`是生成器的核心，它會暫停函數的運行，並將當前的值返回
	- Python 3.5加入動態提示，Python 3.6將typing納入api
	- 模組`mypy`為推薦檢查型態的工具，或是google `pytype` FB `Pyre` MSFT `pyright`
	- `BookCode/samples/Ch04/type_hints/account.py` 中有關於`@overload`的用法，但`@overload` **只用於型別提示**，不會在執行時強制檢查型別
- Ch05 從模組到類別   
	- 架構程式時需要注意
		- 抽象層的封裝與隔離
		- 物件的狀態
		- 名稱空間
		- 資源實體組織方式
	- 模組中定義`__all__`清單或是名稱前有`_`，就可以保證`from module import *`只會import 名稱的變數
	- `del`除了可以刪除變數，也可以刪除引入的模組，但是他是刪除名稱而非物件，可用`sys.modules['deleted_module']`來查看被刪除的變數
	- `sys.path`來源
		- 執行python interpreter的資料夾
		- PYTHONPATH環境變數
		- Python安裝中的標準程式庫資料夾
		- PTH檔案列出的資料夾
			- 可透過`site.getsitepackages()`取得path
			- `site.addsitedir()`可以將PTH檔案放到其他資料夾
	- python中，物件方法的第一個參數一定是物件本身
	- 物件特殊名稱
	    - `__init__()`
	        - 物件的初始化方法，當物件被建立時自動調用，用來設置物件的初始狀態（屬性）。
	    - `__str__()`
	        - 定義當使用 `print()` 或 `str()` 函數時，返回物件的可讀字串表示。這主要是用來提供使用者友好的描述。
	    - `__repr__()`
	        - 定義當使用 `repr()` 函數或在交互式解釋器中輸入物件時，返回物件的正式字串表示。通常應該返回一個可以用來重新創建此物件的表達式。
	- class 內部變數會用`__name`來避免被更改，如果硬要存取需要使用`_classname___name`(較不推薦)或是建立`@property`在同名function上傳遞出來(固定存取原則)
		- 被`@property`標註的`xxx`取值方法，可以使用`@xxx.setter`來設值，`@xxx.deleter`來刪除
	- [[何謂封裝.pdf]]
	- `@staticmehtod` 定義了靜態方法
	- `@classmethod` 定義了類方法
	- 每個物件都有`__dict__()`屬性，記錄著所有特性，如果要看其資料，則使用`var()`來取得
	- `del`的真正作用是刪除某物件的指定屬性
	- `cls` 是類方法的第一個參數，代表類本身，而不是實例。
		- **用法**: 當你定義一個類方法時，你會使用 cls 來引用類的屬性和方法。這意味著你可以在類方法中操作類本身，而不是某個特定的實例。
	- `__new__()`定義了類別實例如何建構
- Ch06 類別的繼承   
	- 鴨子定型的實際意義在於：『思考物件的行為，而非物件的種類！』
	- 在父類別中先行指定`metaclass==`為`abc`模組的`ABCMeta`類別並在指定的method上標注`@abstractmethod`即可強制子類別一定要實作。
	- Rich comparision
		- object定義的`__eq__()`預設用`is`來比較
		- 要定義整組比較方法，使用`functools`的`total_ordering`裝飾器
	- `enum`列舉
		- class加上`@unique`可以使列舉名稱不得重複
	- 多重繼承
	- `@final`可以放在class或method上，使其無法繼承或無法被重新定義
	- Docstrings
		- 多行的函式或method或是簡述在‘’’後面，空一行後再接描述
		- 類別或模組的多行則是，換行再以相同縮排描述
		- 套件則是寫在`__init__.py`中
		- 慣例在python lib中，或是查詢PEP275
	- 官方文件可上網查詢或用`python -m pydoc -p 8080`
	- python中使用`-m`表示執行指定模組的頂層程式流程
	- 泛型
		- 如果想要指定站位型態，使用`typing`中的`TypeVar`
- Ch07 例外處理   
	- python 中例外不一定是錯誤，不少意外代表著一種通知
	- exception右方可以使用tuple來捕捉指定複數種類的例外
	- 例外也有繼承架構
	- 例外都是`BaseException`的子類別
	- 可以先將exception整理為指定資料結構日誌，再raise
		- 當你捕獲到一個異常（OriginalException），但需要在相同的邏輯中重新拋出另一個異常（NewException），並且希望保持原始異常的上下文信息時，可以使用 raise from。
	- 主動引發一個意外許多時候是對呼叫者善盡告知的責任
	- 若事前無法決定import模組名稱，後續可能會以字串方式import，則可使用`importlib`
	- 若想知道例外發生根源，以及多重呼叫下例外的傳播過程，可使用`traceback`
		- 還可以將`traceback`所追蹤的訊息輸出到指定file
		- 或是指定最初或最後的錯誤個數
	- `sys.exc_info()`是簡單輸出例外的方式
	- 警示訊息不會透過`raise`，而是`warning`的`warn()`
	- `else`只有在`try`沒有發生例外時執行
		- 主要功能是要讓可能發生意外的程式碼與`try`放在一起
	- `finally`則是無論如何都會執行
		- 如果在前面`try, else, except`已經`return`，程式也會運行`finally`再`return`
	- `with as`
		- 之後的資源實例透過`as`指定給一變數，離開區塊後就會自動做資源清除的動作
		- 只要物件支持情境管理協定，就可以使用
	- 情境管理協定(Context Management Protocol)
		- 要實作`__enter__()`與`__exit__()`物件
		- 可以使用`contextlib`的`@contextmanager`來讓資源的設定與清除更為直覺
			- 函式中要求要有`try`與`finally`，如果要搭配`with as`則要有`yeild`
- Ch08 open()與io模組   
	- 檔案開啓模式
		- **`r`**: 讀取模式（預設），如果檔案不存在則報錯。
		- **`w`**: 寫入模式，會覆蓋檔案內容，若檔案不存在會創建新檔案。
		- **`x`**: 排他性寫入模式，若檔案已存在則報錯。
		- **`a`**: 附加模式，將資料寫入檔案末尾，若檔案不存在會創建新檔案。
		- **`b`**: 二進位模式，用於讀寫二進位文件，如圖片、影片等。
		- **`t`**: 文字模式（預設），用於讀寫文本文件。
		- **`+`**: 讀寫模式，允許同時讀取和寫入文件。
	- `read()`
		- 方法在沒有指定引數時會讀取檔案所有內容
	- 可以使用`readable`與`writable`來測試權限
	- 對於文字模式來說，預設是讀取到`\n`, `\r`, `\r\n`時都會判斷成一行，但是`readline()`與`readlines()`會將其轉換成`\n`
	- `open()`傳回的檔案物件都實作了`__iter__()`，所以最好的方式是用`for in`而非`read`
	- **`tell()`**: 返回文件當前的讀寫位置，以字節為單位。
	- **`seek(offset, whence)`**: 移動文件的讀寫位置。`offset` 表示要移動的字節數，`whence` 指定移動的基準位置（0: 文件開頭，1: 當前位置，2: 文件末尾）。
	- **`flush()`**: 將文件緩衝區的內容立即寫入硬碟，而不等待自動刷新。
- Ch09 資料結構   
	- hashable物件必須實作`__hash__()`與`__eq__()`
	- 對於python內建型態，只要建立後無法變動的型態，都是hashable
	- 自定義類別所建立的實例預設是hashable，其`__eq__()`是根據`id()`而來
	- Python 3.7增加了 dataclass
		- 設定frozen=True就可變為hashable
		- 可以使用`make_dataclass`來臨時建立dataclass
	- 具有`__iter__()`就是iterable物件
	- 迭代器也是iterable物件
	- python中提供的 `itertools`可協助建立迭代器或產生器
	- python中讀取檔案最好的方式就是不要去`read`，甚至可以將`file`用`set`讀取
	- 如果想要自訂class是orderable，可使用`sorted`，那需要定義`__lt__()`
	- `sorted`的`key`除了使用`lambda`設定之外，還可以使用`operator`模組的`itemgetter`或是`attrgetter`
	- 群集架構
		- 循序類型
			- list, tuple, range
			- str, bites, bytearray
			- 共同行為
				- `x in s`
				- `x not in s`
				- `s + t`
				- `s * n`
				- `s[i]`
				- `s[i:j]`
				- `s[i:j:k]`
				- `len(s)`
				- `mix(s)`
				- `max(s)`
				- `s.index(x[, i[, j]])`
				- `s.count(x)`
			- 可變動的循序類型(沒有`hash()`)共同行為
				- s[i] = x
				- s[i:j] = t 
				- del s[i:j]
				- s[i:j:k] = t
				- del s[i:j:k]
				- s.append(x)
				- s.clear()
				- s.copy()
				- s.extend()
				- s.insert(i, x)
				- s.pop([i])
				- s.remove(x)
				- s.reverse()
		- 集合類型
			- 不會重複，是無序類型，元素必須是hashable物件
			- 可以使用`in, not in, len(), &, |, -, ^, intersection(), union(), difference(), symmetric_difference()`
		- 映射類型
		- 使用`collections`模組可以找到進階的群集相關函式與方法
			- `deque`
			- `nametuple`
			- `OrdereDict`
			- `defaultdict`
			- `Counter`
			- `Chainmap`
			- `UserList`
			- `UserDict`
			- `UserString`
		- 自己實作群集(BookCode/samples/CH09/collection_advanced/chainmap.py)
			- `__getitem__()`可以用`[]`取值
			- `__setitem__()`可以實現`[]`預設值
			- `__delitem__()`可以透過`del`和`[]`刪除
		- 可以繼承`collection.abc`內的物件以避免有必要方法沒有實作
- Ch10 資料永續與交換   
	- `pickle`模組
		- Pickling: 將python物件轉換為bytes，相反為unpickling
	- `shelve`模組
		- 像是字典的物件，類似簡單的資料庫介面，底層是使用dbm
		- 以pickle為基礎的模組
	- Python 標準規範是DB-API 2.0
		- PEP 249
		- 要有connect 函式`close()`, `commit()`, `rollback()`, `cursor([cursorClass])`
		- 標準程式庫的`sqlite3`為合規之一
	- 交易基本需求(ACID)
		- 原子性
		- 一致性
		- 隔離性
			- 無隔離會發生Lost Update, Dirty read, Unrepeatable read, Phantom read
		- 持續性
	- 通用資料格式
		- CSV
		- JSON
			- 名稱須以`""`
			- 值可以是`""`包括的字串
		- XML
- Ch11 常用內建模組   
	- `datetime`
	- `logging`
	- `re`
	- `os`
	- `glob`
	- `urllib`
	- `request`
- Ch12 除錯、測試與效能   
	- 測試
		- 使用assert斷言
		- 建議範圍
			- 前置條件斷言客戶端呼叫函式前，已具備某些條件
			- 後製條件驗證客戶端後，具有函式承諾之結果
			- 類別不變量驗證物件某時間下的狀態
			- 內部不變量使用斷言代替註解
			- 流程不變量斷言程式流程中絕對不會執行到的程式碼部分
		- [避免隱藏錯誤的防禦性設計](https://www.ithome.com.tw/voice/81659)
		- `doctest` 
			- 如果撰寫了REPL的執行範例，執行時再加上-v，可以追加顯示細節 (如: BookCode/samples/CH12/doctest_demo/util.py)
		- `unittest`
			- 也稱為PyUnit
			- 四個部分
				- 測試案例
					- 如BookCode/samples/CH12/unittest_demo/
					- 單元測試直接運行測試腳本
					- 腳本測試會自動找出`unittest`類別中以`test_`為開頭的方法
				- 測試設備
					- 在`unittest`類別中如果有定義`setUp()`與`tearDown()`就會在test開頭與結尾呼叫
				- 測試套件
				- 測試執行器
		- `timeit`
		- `cProfile` or `profile`
- Ch13 並行、平行與非同步   
	- `threading`
		- 使用的場合之一，是輸入輸出密集的場合
		- 計算密集反而不見得有用，甚至可能更差
		- 可以設定Daemon，True都執行完就會結束
		- 可以安插執行緒
		- 競速
		- 鎖定
		- 死結
		- 等待與通知
		- Semaphore 與 Barrier
	- `subprocess`
	- `multiprocessing`
		-  `multiprocessing` — Process-based parallelism[¶](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing "Link to this heading")
		- `if __name__ == '__main__':`是必要的
	- `concurrent.features`
		- `ThreadPoolExecutor`
		- `ProcessPoolExecutor`
	- 非同步編程則允許程序在等待某個操作的結果時，繼續執行其他代碼，從而提高資源利用率和效率。
	- `asyncio`
	- `async`
	- `await`
- Ch14 進階主題   
	- 描述器(Descrptor)
		- 必須擁有`__get__()`, `__set__()`, `__delete__()`
		- 描述屬性的取得、設定與刪除如何處理的物件
	- 函式裝飾器
		- 透過`functools.warp`會更好
	- 類別裝飾器
	- 方法裝飾器
	- 相對匯入
		- 在`__init__.py`如`from . import ...`
